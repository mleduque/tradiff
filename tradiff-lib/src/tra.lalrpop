use crate::tra_structs::{ExplicitTraEntry, TraComment, TraEntry, TraEntryContent, TraFragment, WeiduString, WeiduStringLit};
use lalrpop_util::{ErrorRecovery};

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, &'static str>>);

WeiduStringLit : WeiduStringLit = {
    <s:r"~[^~]*~"> => WeiduStringLit::Tilde(s[1..s.len()-1].to_string()),
    <s:r#""[^"]*""#> => WeiduStringLit::DoubleQuote(s[1..s.len()-1].to_string()),
    <s:r"%[^%]*%"> => WeiduStringLit::Percent(s[1..s.len()-1].to_string()),
    <s:r"~~~~~([^~]*|[^~]*~[^~]*|[^~]*~~[^~]*|[^~]*~~~[^~]*|[^~]*~~~~[^~]*)~~~~~">
                                => WeiduStringLit::FiveTildes(s[5..s.len()-5].to_string()),
};

WeiduString: WeiduString = {
    WeiduStringLit => WeiduString::Literal(<>),
    <s1: WeiduString> "^" <s2: WeiduStringLit> => WeiduString::Concat(Box::new(s1), Box::new(s2))
};

// refer to https://gibberlings3.github.io/iesdp/file_formats/ie_formats/key_v1.htm
// This is probably limited to 1-byte characters (not taking encoding into account, probably
// just a binary value) excepting ASCIIZ (used as terminating character).
// The filename seems to be counted using 2-bytes but I wouldn't count on it being this big.
SoundRef: String = <s:r"\[[^\]]+\]"> => s[1..s.len()-1].into();

// Can be negative AFAI Saw
TraId: i64 = "@" <s:r"-?[0-9]+"> => i64::from_str_radix(s, 10).unwrap();
TlkRef: u32 = "#" <s:r"-?[0-9]+"> => u32::from_str_radix(s, 10).unwrap();

GenderSpec: (WeiduString, Option<String>) = <value: WeiduString> <sound: SoundRef?>
    => (value, sound);

TraEntry: TraEntry = {
    <id: TraId> "=" <male: GenderSpec ><female: GenderSpec?> => TraEntry {
        id,
        content: TraEntryContent::Explicit(ExplicitTraEntry {
            value: male.0,
            sound: male.1,
            alt_value: female.clone().map(|ref female| female.0.clone()),
            alt_sound: female.map(|female| female.1).flatten(),
        }),
    },
    <id: TraId> "=" <other_id: TraId> => TraEntry {
        id,
        content: TraEntryContent::At(other_id),
    },
    <id: TraId> "=" <tlk_ref: TlkRef> => TraEntry {
        id,
        content: TraEntryContent::Tlk(tlk_ref),
    },
};

TraComment: TraComment = {
    <s:r"//[^\n]*\r\n"> => TraComment::EndOfLine(s[2..s.len() - 2].into()),
    <s:r"//[^\n]*[^\r]\n"> => TraComment::EndOfLine(s[2..s.len() - 1].into()),
    <s:r"/\*([^\*]*|\*[^/]*)\*/"> => TraComment::Enclosed(s[2..s.len() - 2].into()),
};

TraFragment: TraFragment = {
    TraEntry => TraFragment::Entry(<>),
    TraComment => TraFragment::Comment(<>),
    ! => { errors.push(<>); TraFragment::Error },
};

pub TraFile: Vec<TraFragment> = <TraFragment*> => <>;
